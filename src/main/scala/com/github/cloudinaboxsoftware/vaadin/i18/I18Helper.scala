package com.github.cloudinaboxsoftware.vaadin.i18

import java.io.{FileWriter, BufferedWriter, File}
import io.Source
import java.util.Date
import com.github.cloudinaboxsoftware.vaadin.util.LogUtil

object Lang {
  type Lang = String

  type TString = (Lang => String)

  val defaultLang = "en"
}

object I18Helper {

  def parseLanguage(lines: Seq[String], lang: String): Map[String, String] = {
    val grupped = lines.flatMap(l => {
      if (!l.isEmpty && l.charAt(0) != ' ' && l.contains('=')) {
        Some((normalize(l.substring(0, l.indexOf('='))), l.substring(l.indexOf('=') + 1, l.length)))
      } else None
    }).groupBy(_._1)
    grupped.filter(_._2.size > 1).foreach(duplicate => {
      println("WARN(" + lang + "): key '" + duplicate._1 + "' has duplicate values:" + duplicate._2.map(_._2).mkString("\n\t", "\n\t", "\n"))
    })
    grupped.mapValues(_.head._2)
  }

  def main(args: Array[String]) {
    val bw = new BufferedWriter(new FileWriter(args(1)))
    bw.write(generate(args(0), args(1)))
    bw.close()
  }

  def normalize(key: String) = key.toUpperCase.replace(' ', '_')

  def generate(langPacksPath: String, outputPath: String) = {
    val langPackFiles = new File(langPacksPath).listFiles().filter(_.getName.endsWith("langpack"))
    val languages = langPackFiles.map(f => {
      val lang = f.getName.substring(0, f.getName.length - ".langpack".length)
      val kvals = parseLanguage(Source.fromFile(f).getLines().toSeq, lang)
      (lang, kvals)
    }).toMap

    val allKeys = languages.values.flatMap(_.keys).toSet

    allKeys.foreach(key => languages.foreach(lang => if (!lang._2.get(key).isDefined) println("WARN: key '" + key + "' undefined for language '" + lang._1 + "'")))

    "package pt.com.ciab.architectum.i18" + "\n\n" +
      "import pt.com.ciab.architectum.util.LogUtil" + "\n" +
      "import pt.com.ciab.architectum.model.User" + "\n\n\n" +
      "/* Generated by " + System.getenv("USER") + " at " + new Date() + " */" + "\n\n\n" +
      "object I18 {" + "\n" + "\n" +
      "  type Lang = String" + "\n" + "\n" +
      "  type TString = (Lang => String)" + "\n" + "\n" +
      generateTString() + "\n" + "\n" +
      languages.map(l => generateLanguage(l._1, l._2, allKeys)).mkString("\n") + "\n" +
      generateI18(languages.keySet) +
      generateLangPack(allKeys, languages) +
      "}" + "\n" + "\n"
  }

  def generateTString() =
    """
      |  val defaultLang = "en"
      |
      |  def translate(key: String, lang: Lang, replaces: Map[String, String] = Map()): String = {
      |    langs.get(lang) match {
      |      case Some(language) => language.get(key) match {
      |        case Some(translation) => replaces.foldLeft(translation)((trns, kv) => trns.replace("{" + kv._1 + "}", kv._2))
      |        case None => {
      |          if (lang == defaultLang) {
      |            throw new Exception("Bug: translation is not available for key '" + key + "' in default language '" + lang + "'")
      |          }
      |          else {
      |            LogUtil.Log.error("Bug: translation is not available for key '" + key + "' in language '" + lang + "' resorting to " + defaultLang.toUpperCase)
      |            translate(key, defaultLang, replaces)
      |          }
      |        }
      |      }
      |      case None => throw new Exception("Bug: language '" + lang + "' is not available")
      |    }
      |  }
      |
      |  def uc(s: String) = s.splitAt(1) match {case (s1, s2) => s1.toUpperCase + s2 }
      |
      |  def lc(s: String) = s.splitAt(1) match {case (s1, s2) => s1.toLowerCase + s2 }
      |
      |  def cl(s: String) = if (s.endsWith(":")) s else s + ":"
      |
      |  """.stripMargin

  def generateLanguage(name: String, kvals: Map[String, String], allKeys: Set[String]) = {
    "  val " + name.toUpperCase + " = " +
      kvals.toList.sortBy(_._1).map(kv => "             |" + kv._1 + "=" + kv._2).mkString("\"\"\" \n", "\n", "\n\"\"\".stripMargin") +
      "\n" + "\n"
  }

  def generateI18(languages: Set[String]) = {
    "  val langs = Map(" + languages.map(name => "(\"" + name + "\", I18Helper.parseLanguage(" + name.toUpperCase + ".split('\\n'), \"" + name + "\"))").mkString(", ") + ")" + "\n" + "\n"
  }

  def generateLangPack(allKeys: Set[String], languages: Map[String, Map[String, String]]) = {
    allKeys.map(key =>
      List(
        ("MODIFIERS: None. Original string as is in file.", List()),
        ("MODIFIERS: Ensures that the string starts with uppercase.", List("uc")),
        ("MODIFIERS: Ensures that the string starts with lowercase.", List("lc")),
        ("MODIFIERS: Ensures that the string starts with uppercase and ends with colon.", List("uc", "cl"))).map(modifiers => {
        "  /**" + "\n" +
          "   * Language-specific text with key '" + key + "'" + "\n" +
          "   * " + modifiers._1 + "\n" +
          "   * Original values (no modifiers) at " + new Date() + ":" + "\n" +
          languages.map(lang => "   * " + lang._1 + ": " + (lang._2.get(key) match {case Some(s) => "'" + s + "'" case None => "UNDEFINED!"})).mkString("\n") + "\n" +
          "   */" + "\n" +
          "  " + generateType(key, languages.flatMap(_._2.get(key)).head, modifiers._2)
      }).mkString("\n\n")).mkString("\n\n") + "\n\n" +
      "  def UNDEFINED: String = throw new Exception(\"Asked for the undefined key!\")" + "\n"
  }

  def generateType(key: String, example: String, modifiers: List[String] = List()): String = {
    val args = (0 to 9).filter(i => example.contains("{" + i + "}"))
    if (args.isEmpty)
      "def " + key + (if (modifiers.size > 0) modifiers.map(_.toUpperCase).mkString("_", "_", "") else "") + "()(implicit lang: Lang): String" + " = " + modifiers.map(_ + "(").mkString + "translate(\"" + key + "\", lang)" + modifiers.map(_ => ")").mkString
    else
      "def " + key + (if (modifiers.size > 0) modifiers.map(_.toUpperCase).mkString("_", "_", "") else "") + "(" + args.map(a => "p" + a + ": String").mkString(", ") + ")(implicit lang: Lang): String" + " = " + modifiers.map(_ + "(").mkString + "translate(\"" + key + "\", lang, List(" + args.map(a => "(\"" + a + "\", p" + a + ")").mkString(", ") + ").toMap)" + modifiers.map(_ => ")").mkString
  }

  def fileInLang(f: File, lang: Lang.Lang) = {

    val fUserLang = new java.io.File(f.getAbsolutePath + "_" + lang)
    val fFDefaultLang = new java.io.File(f.getAbsolutePath + "_" + Lang.defaultLang)
    val fUnknownLang = f

    if (fUserLang.exists()) {
      LogUtil.Log.info("Selecting file '" + f.getName + "' in user language ('" + lang + "')")
      fUserLang
    } else if (fFDefaultLang.exists()) {
      LogUtil.Log.info("Selecting file '" + f.getName + "' in default language ('" + Lang.defaultLang + "')")
      fFDefaultLang
    } else if (fUnknownLang.exists()) {
      LogUtil.Log.warn("Selecting file '" + f.getName + "' in an unknown language. No suitable language found (neither '" + lang + "' nor '" + Lang.defaultLang + "').")
      fUnknownLang
    } else {
      throw new Exception("No suitable language found for file '" + f.getName + "'")
    }
  }

  val langCodes3CharTo2Char = Map(
    "abk" -> "ab",
    "aar" -> "aa",
    "afr" -> "af",
    "aka" -> "ak",
    "sqi" -> "sq",
    "sqi" -> "sq",
    "amh" -> "am",
    "ara" -> "ar",
    "arg" -> "an",
    "arm" -> "hy",
    "hye" -> "hy",
    "asm" -> "as",
    "ava" -> "av",
    "ave" -> "ae",
    "aym" -> "ay",
    "aze" -> "az",
    "bam" -> "bm",
    "bak" -> "ba",
    "baq" -> "eu",
    "eus" -> "eu",
    "bel" -> "be",
    "ben" -> "bn",
    "bih" -> "bh",
    "bis" -> "bi",
    "nob" -> "nb",
    "bos" -> "bs",
    "bre" -> "br",
    "bul" -> "bg",
    "bur" -> "my",
    "mya" -> "my",
    "spa" -> "es",
    "cat" -> "ca",
    "khm" -> "km",
    "cha" -> "ch",
    "che" -> "ce",
    "nya" -> "ny",
    "nya" -> "ny",
    "chi" -> "zh",
    "zho" -> "zh",
    "zha" -> "za",
    "chu" -> "cu",
    "chu" -> "cu",
    "chv" -> "cv",
    "cor" -> "kw",
    "cos" -> "co",
    "cre" -> "cr",
    "hrv" -> "hr",
    "cze" -> "cs",
    "ces" -> "cs",
    "dan" -> "da",
    "div" -> "dv",
    "div" -> "dv",
    "dut" -> "nl",
    "nld" -> "nl",
    "dzo" -> "dz",
    "eng" -> "en",
    "epo" -> "eo",
    "est" -> "et",
    "ewe" -> "ee",
    "fao" -> "fo",
    "fij" -> "fj",
    "fin" -> "fi",
    "dut" -> "nl",
    "nld" -> "nl",
    "fre" -> "fr",
    "fra" -> "fr",
    "ful" -> "ff",
    "gla" -> "gd",
    "glg" -> "gl",
    "lug" -> "lg",
    "geo" -> "ka",
    "kat" -> "ka",
    "ger" -> "de",
    "deu" -> "de",
    "kik" -> "ki",
    "gre" -> "el",
    "ell" -> "el",
    "kal" -> "kl",
    "grn" -> "gn",
    "guj" -> "gu",
    "hat" -> "ht",
    "hat" -> "ht",
    "hau" -> "ha",
    "heb" -> "he",
    "her" -> "hz",
    "hin" -> "hi",
    "hmo" -> "ho",
    "hun" -> "hu",
    "ice" -> "is",
    "isl" -> "is",
    "ido" -> "io",
    "ibo" -> "ig",
    "ind" -> "id",
    "ina" -> "ia",
    "ile" -> "ie",
    "iku" -> "iu",
    "ipk" -> "ik",
    "gle" -> "ga",
    "ita" -> "it",
    "jpn" -> "ja",
    "jav" -> "jv",
    "kal" -> "kl",
    "kan" -> "kn",
    "kau" -> "kr",
    "kas" -> "ks",
    "kaz" -> "kk",
    "kik" -> "ki",
    "kin" -> "rw",
    "kir" -> "ky",
    "kom" -> "kv",
    "kon" -> "kg",
    "kor" -> "ko",
    "kua" -> "kj",
    "kur" -> "ku",
    "kua" -> "kj",
    "kir" -> "ky",
    "lao" -> "lo",
    "lat" -> "la",
    "lav" -> "lv",
    "ltz" -> "lb",
    "lim" -> "li",
    "lim" -> "li",
    "lim" -> "li",
    "lin" -> "ln",
    "lit" -> "lt",
    "lub" -> "lu",
    "ltz" -> "lb",
    "mac" -> "mk",
    "mkd" -> "mk",
    "mlg" -> "mg",
    "may" -> "ms",
    "msa" -> "ms",
    "mal" -> "ml",
    "div" -> "dv",
    "mlt" -> "mt",
    "glv" -> "gv",
    "mao" -> "mi",
    "mri" -> "mi",
    "mar" -> "mr",
    "mah" -> "mh",
    "rum" -> "ro",
    "ron" -> "ro",
    "mon" -> "mn",
    "nau" -> "na",
    "nav" -> "nv",
    "nav" -> "nv",
    "nde" -> "nd",
    "nbl" -> "nr",
    "ndo" -> "ng",
    "nep" -> "ne",
    "nde" -> "nd",
    "sme" -> "se",
    "nor" -> "no",
    "nob" -> "nb",
    "nno" -> "nn",
    "iii" -> "ii",
    "nya" -> "ny",
    "nno" -> "nn",
    "ile" -> "ie",
    "oci" -> "oc",
    "oji" -> "oj",
    "chu" -> "cu",
    "chu" -> "cu",
    "chu" -> "cu",
    "ori" -> "or",
    "orm" -> "om",
    "oss" -> "os",
    "oss" -> "os",
    "pli" -> "pi",
    "pan" -> "pa",
    "pus" -> "ps",
    "per" -> "fa",
    "fas" -> "fa",
    "pol" -> "pl",
    "por" -> "pt",
    "pan" -> "pa",
    "pus" -> "ps",
    "que" -> "qu",
    "rum" -> "ro",
    "ron" -> "ro",
    "roh" -> "rm",
    "run" -> "rn",
    "rus" -> "ru",
    "smo" -> "sm",
    "sag" -> "sg",
    "san" -> "sa",
    "srd" -> "sc",
    "gla" -> "gd",
    "srp" -> "sr",
    "sna" -> "sn",
    "iii" -> "ii",
    "snd" -> "sd",
    "sin" -> "si",
    "sin" -> "si",
    "slo" -> "sk",
    "slk" -> "sk",
    "slv" -> "sl",
    "som" -> "so",
    "sot" -> "st",
    "nbl" -> "nr",
    "spa" -> "es",
    "sun" -> "su",
    "swa" -> "sw",
    "ssw" -> "ss",
    "swe" -> "sv",
    "tgl" -> "tl",
    "tah" -> "ty",
    "tgk" -> "tg",
    "tam" -> "ta",
    "tat" -> "tt",
    "tel" -> "te",
    "tha" -> "th",
    "tib" -> "bo",
    "bod" -> "bo",
    "tir" -> "ti",
    "ton" -> "to",
    "tso" -> "ts",
    "tsn" -> "tn",
    "tur" -> "tr",
    "tuk" -> "tk",
    "twi" -> "tw",
    "uig" -> "ug",
    "ukr" -> "uk",
    "urd" -> "ur",
    "uig" -> "ug",
    "uzb" -> "uz",
    "cat" -> "ca",
    "ven" -> "ve",
    "vie" -> "vi",
    "vol" -> "vo",
    "wln" -> "wa",
    "wel" -> "cy",
    "cym" -> "cy",
    "fry" -> "fy",
    "wol" -> "wo",
    "xho" -> "xh",
    "yid" -> "yi",
    "yor" -> "yo",
    "zha" -> "za",
    "zul" -> "zu"
  )
}

